import { JWT } from "google-auth-library";
import { GoogleSpreadsheet } from "google-spreadsheet";
import dotenv from "dotenv";
dotenv.config();

// Initialize auth - see https://theoephraim.github.io/node-google-spreadsheet/#/guides/authentication
const serviceAccountAuth = new JWT({
  // env var values here are copied from service account credentials generated by google
  // see "Authentication" section in docs for more info
  email: process.env.JWT_SERVICE_ACCOUNT_EMAIL,
  key: process.env.JWT_PRIVATE_KEY.split(String.raw`\n`).join("\n"),
  scopes: ["https://www.googleapis.com/auth/spreadsheets"],
});

const doc = new GoogleSpreadsheet(
  process.env.GOOGLE_SHEET_ID,
  serviceAccountAuth
);

export const setHeaderRow = async (typeSearch) => {
  await doc.loadInfo(); // loads document properties and worksheets

  const sheet =
    doc.sheetsByIndex[
      typeSearch === "search-1" ? 0 : typeSearch === "search-2" ? 1 : 2
    ]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`

  // append rows
  await sheet.loadCells("A1:Z100000"); // loads range of cells into local cache - DOES NOT RETURN THE CELLS
  let index = 0;
  let emptyCell;
  while (true) {
    const cell = sheet.getCell(0, index);
    if (!cell.value) {
      emptyCell = cell;
      break;
    }
    index++;
  }
  const date = new Date();
  const formattedDate = date.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
  });
  emptyCell.value = formattedDate;
  await sheet.saveUpdatedCells();
  return {
    rowIndex: 0,
    columnIndex: index,
    sheet,
  };
};

export const setNewsInfo = async (newsInfo, sheetInfo, typeSearch) => {
  const { columnIndex, sheet } = sheetInfo;

  let rowMaxIndex = 0;
  const arrCell = [];
  let getInfo = {};
  newsInfo.forEach((news, index) => {
    console.log("Start set news info");
    // eslint-disable-next-line no-unused-expressions
    getInfo[`page-${index}`] = news?.articles?.length;
    // eslint-disable-next-line no-unused-expressions
    news?.articles?.forEach((newsItem, index) => {
      const rowIndex = index + 1;
      const cell = sheet.getCell(rowIndex, columnIndex);
      rowMaxIndex += 1;
      cell.value = JSON.stringify(
        {
          ArticleId: `${newsItem.id}`,

          Title: `${newsItem.title}`,

          "Publication Date": `${newsItem.published_date}`,

          "Source/Publication": `${newsItem.name_source}`,

          Author: `${newsItem.author}`,

          URL: `${newsItem.link}`,

          Content: `${newsItem.content?.substring(0, 40000)}`,

          "Article Score": `${newsItem.score}`,

          "Domain URL": `${newsItem.domain_url}`,

          Country: `${newsItem.country}`,

          Language: `${newsItem.language}`,

          "Word Count": `${newsItem.word_count}`,

          "Media Type": `${newsItem.media_type}`,

          "Is Opinion": `${newsItem.is_opinion}`,

          "AI Summary": "AI_TODO",

          Relevance: "AI_TODO",

          Theme: `${newsItem.theme}`,

          "Sentiment Score Title": `${newsItem.nlp.sentiment.title}`,

          "Sentiment Score Content": `${newsItem.nlp?.sentiment?.content}`,

          "Entities People": `${JSON.stringify(newsItem.nlp.ner_PER)}`,

          "Entities Organizations": `${JSON.stringify(newsItem.nlp.ner_ORG)}`,

          "Entities Locations": `${JSON.stringify(newsItem.nlp.ner_LOC)}`,

          "IPTC Tags": `${newsItem.nlp.iptc_tags_name}`,

          "Search Date": `${new Date()}`,

          "Processing Date": "AI_TODO",
        },
        null,
        4
      );
      arrCell.push(newsItem);
    });
  });
  console.log("getInfo", getInfo);
  console.log("rowMaxIndex", rowMaxIndex);
  localStorage.setItem(
    `last-articles-position-${typeSearch}`,
    JSON.stringify({ rowMaxIndex, columnIndex })
  );

  console.log("Ended set news info", newsInfo.length);
  await sheet.saveUpdatedCells();
  return { rowMaxIndex, columnIndex };
};

export const findReasoning = (text, type) => {
  const reasoningRegex =
    type === "summary"
      ? /SUMMARY:\s*([\s\S]*?)(?=\n\n|$)/
      : type === "relevant"
      ? /RELEVANT:\s*([\s\S]*?)(?=\n\n|$)/
      : /REASONING:\s*([\s\S]*?)(?=\n\n|$)/;
  const match = text.match(reasoningRegex);
  return match ? match[1].trim() : null;
};

export const editCellAi = async (cell, aiInfo, typeSearch) => {
  try {
    await doc.loadInfo(); // loads document properties and worksheets
    const sheet =
      doc.sheetsByIndex[
        typeSearch === "search-1" ? 0 : typeSearch === "search-2" ? 1 : 2
      ]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
    await sheet.loadCells("A1:Z100000");
    const cellInfo = sheet.getCell(cell.row, cell.column);
    let resCell = cellInfo.value;
    resCell = resCell.replace(
      `"Relevance": "AI_TODO"`,
      `"Relevance": "${findReasoning(aiInfo, "relevant")}"`
    );
    resCell = resCell.replace(
      `"AI Summary": "AI_TODO"`,
      `"AI Summary": "${findReasoning(aiInfo, "summary")}"`
    );
    resCell = resCell.replace(
      `"Processing Date": "AI_TODO"`,
      `"Processing Date": "${new Date().toString()}"`
    );

    cellInfo.value = resCell;
    console.log("end editCellAi", resCell);

    await sheet.saveUpdatedCells();
  } catch (error) {
    console.log("error editCellAi", error);
  }
};

export const bootstrapSheet = async (newsInfo, typeSearch) => {
  const sheetInfo = await setHeaderRow(typeSearch);
  const position = await setNewsInfo(newsInfo, sheetInfo, typeSearch);
  return position;
};
